-- Minimal Luau → Lua 5.1 normalizer:
--  - rewrites compound assignment (+=, -=, *=, /=, %=, ..=)
--  - lowers `continue` in for/while via a repeat/until shim
--  - preserves strings/comments by masking first

local M = {}

-- ---------- mask strings/comments so rewrites avoid them ----------
local function mask_all(s)
  local out, pool = {}, {}
  local function store(a,b)
    local id = #pool+1
    pool[id] = s:sub(a,b)
    out[#out+1] = "\1"..id.."\2"
  end
  local i, n = 1, #s
  while i <= n do
    local c = s:sub(i,i)

    -- long comment: --[=*[ ... ]=*]
    if c=="-" and i+1<=n and s:sub(i+1,i+1)=="-" and i+2<=n and s:sub(i+2,i+2)=="[" then
      local j=i+3; local eq=0
      while j<=n and s:sub(j,j)=="=" do eq=eq+1; j=j+1 end
      if j<=n and s:sub(j,j)=="[" then
        j=j+1
        local _,k = s:find("%]"..string.rep("=",eq).."%]", j)
        if k then store(i,k); i=k+1 goto cont end
      end
    end

    -- short comment: -- … to EOL
    if c=="-" and i+1<=n and s:sub(i+1,i+1)=="-" then
      local j = (s:find("[\r\n]", i+2) or (n+1)) - 1
      store(i, j); i = j+1; goto cont
    end

    -- long string: [=*[ ... ]=*]
    if c=="[" then
      local j=i+1; local eq=0
      while j<=n and s:sub(j,j)=="=" do eq=eq+1; j=j+1 end
      if j<=n and s:sub(j,j)=="[" then
        j=j+1
        local _,k = s:find("%]"..string.rep("=",eq).."%]", j)
        if k then store(i,k); i=k+1 goto cont end
      end
    end

    -- short string: '...' or "..."
    if c=="'" or c=='"' then
      local q=c; local j=i+1
      while j<=n do
        local cj=s:sub(j,j)
        if cj=="\\" then j=j+2
        elseif cj==q then j=j+1 break
        else j=j+1 end
      end
      if j>n then j=n end
      store(i, j-1); i=j; goto cont
    end

    out[#out+1] = c
    i = i + 1
    ::cont::
  end
  return table.concat(out), pool
end

local function unmask(s, pool)
  return (s:gsub("\1(%d+)\2", function(id) return pool[tonumber(id)] end))
end

-- ---------- compound assignment (per-line, pure Lua patterns) ----------
local OPS = { ["..="]="..", ["+="]="+", ["-="]="-", ["*="]="*", ["/="]="/", ["%="]="%" }
local function trim(x) return (x:gsub("^%s+",""):gsub("%s+$","")) end

local function rewrite_compound(masked)
  local out = {}
  for line in (masked.."\n"):gmatch("(.-)\r?\n") do
    local changed = true
    while changed do
      changed = false
      local best_i, best_op
      for op,_ in pairs(OPS) do
        local i = line:find(op, 1, true)
        if i and (not best_i or i < best_i) then best_i, best_op = i, op end
      end
      if best_i then
        local i, op = best_i, best_op
        local bin = OPS[op]

        -- LHS: from last separator to just before op
        local before = line:sub(1, i-1)
        local lstart = (before:match("()[^;{}()%[%]\n]*$")) or 1
        local prefix = line:sub(1, lstart-1)
        local lhs = trim(line:sub(lstart, i-1))
        if lhs == "" then break end

        -- RHS: everything after the operator
        local rhs = trim(line:sub(i + #op))

        line = prefix .. lhs .. " = " .. lhs .. " " .. bin .. " (" .. rhs .. ")"
        changed = true
      end
    end
    out[#out+1] = line
  end
  return table.concat(out, "\n")
end

-- ---------- lower `continue` using a repeat/until shim ----------
local function lower_continue(masked)
  local out, i, n = {}, 1, #masked
  local depth = 0
  local loopstack = {}   -- depths where we opened a shim
  local pending_do = false

  local function append(s) out[#out+1] = s end
  local function read_ident()
    local j=i; while j<=n and masked:sub(j,j):match("[%w_]") do j=j+1 end
    return masked:sub(i,j-1), j
  end

  while i<=n do
    local c = masked:sub(i,i)

    if c=="\n" or c=="\r" then
      pending_do=false; append(c); i=i+1; goto cont
    end

    if c:match("[%a_]") then
      local id, j = read_ident()

      if id=="for" or id=="while" then
        depth = depth + 1
        pending_do = true
        append(id); i=j; goto cont
      end

      if id=="do" then
        append("do"); i=j
        if pending_do then
          append("\n" .. string.rep(" ", depth*2) .. "repeat\n")
          loopstack[#loopstack+1] = depth
          pending_do = false
        else
          depth = depth + 1
        end
        goto cont
      end

      if id=="end" then
        if #loopstack>0 and loopstack[#loopstack]==depth then
          loopstack[#loopstack] = nil
          append(string.rep(" ", depth*2) .. "until true\n")
        end
        depth = math.max(0, depth-1)
        append("end"); i=j; goto cont
      end

      if id=="until" then
        depth = math.max(0, depth-1)
        append("until"); i=j; goto cont
      end

      if id=="continue" then
        append(#loopstack>0 and "break" or "continue")
        i=j; goto cont
      end

      append(id); i=j; goto cont
    end

    append(c); i=i+1
    ::cont::
  end

  return table.concat(out)
end

-- ------------------------------ public API ------------------------------
function M.normalize(source)
  local masked, pool = mask_all(source)
  masked = rewrite_compound(masked)
  masked = lower_continue(masked)
  return unmask(masked, pool)
end

return M

